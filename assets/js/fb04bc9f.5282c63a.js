"use strict";(self.webpackChunkliveui_website=self.webpackChunkliveui_website||[]).push([[8366],{4137:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1740:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),o=n(3366),i=(n(7294),n(4137)),r=["components"],s={id:"muto",title:"Muto",sidebar_label:"Muto",sidebar_position:1},l=void 0,c={unversionedId:"muto/muto",id:"muto/muto",title:"Muto",description:"Background:",source:"@site/docs/muto/index.md",sourceDirName:"muto",slug:"/muto/",permalink:"/docs/docs/muto/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/muto/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"muto",title:"Muto",sidebar_label:"Muto",sidebar_position:1},sidebar:"mutoSidebar",next:{title:"Muto Edge",permalink:"/docs/docs/muto-edge/"}},d={},p=[{value:"Background:",id:"background",level:2},{value:"Scope",id:"scope",level:2},{value:"Runtime",id:"runtime",level:2},{value:"Agent",id:"agent",level:3},{value:"Device Telemetry",id:"device-telemetry",level:3},{value:"Command Relay",id:"command-relay",level:3},{value:"Composer",id:"composer",level:3},{value:"Dashboard",id:"dashboard",level:3},{value:"LiveUI",id:"liveui",level:3},{value:"Where to start?",id:"where-to-start",level:2}],u={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"background"},"Background:"),(0,i.kt)("p",null,"Autonomous driving and connectivity are cornerstones of the next generation of mobility. Users expect mobility experience to be personal, seamlessly integrated, connected and with demand services that can adapt to their immediate needs. These systems demand immense computing power in order to mimic the adaptivity and the awareness of a human driver under different driving circumstances and context variations. Contextual adaptivity requires a system to make sense of large volumes of rich & continuous data coming from the devices, the user behavior and the environment."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"../../img/muto-splash.png"})),"Many solutions use hardwired, closed & proprietary software with often unexplainable built-in biases. Robot Operating System (ROS) allows a modular system to be designed as a fully distributed computation, so different functional modules (i.e. sensing, perception, decision, planning, actuation, etc) can act together as a single autonomous vehicle.",(0,i.kt)("p",null,"A challenge with a typical ROS based hardwired solution is that the components (nodes, a network of interconnected computational and executable units) constituting the system are deployed into an environment to fulfill a certain concern with a specific mission plan, and they are not typically designed or implemented to react and to adapt changing requirements in the environment.  A major difficulty that prevails for any adaptive system is being able to update the system without compromising its mission, plan, safety and security while it is active because the damages could be substantial."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"scope"},"Scope"),(0,i.kt)("p",null,"Eclipse Muto provides an adaptive framework and a runtime platform for dynamically composable model-driven ROS software stacks on autonomous vehicles and robots in general.  "),(0,i.kt)("p",null,"Eclipse Muto introduces the concept of a lightweight model for ROS software stacks, which in its simplest form is a model for the system of connected ROS nodes and the context for which it is applicable. The Muto Agent and Muto Composer are ROS based runtimes designed to run on edge devices (i.e. AVs). Muto Dashboard is an extensible Web/Mobile application for centralized management of edge devices and Muto stacks deployed on these devices. Muto Composer runtime can introspect and change (i.e launch, stop, restart, configure, etc.) the network of distributed components running on a device using the Muto Stack definitions.  Muto Agent allow remote management and monitoring of the devices and stacks and uses eclipse IoT technology such as Eclipse Ditto to define a digital twin for each device providing synchronous and asynchronous APIs and use the digital twin API to manage Muto stacks and ROS behavior.  "),(0,i.kt)("p",null,"The adaptive behavior is introduced by an extensible model where the context detection, stack rewriting, validation, constraint satisfaction, safety and security concerns can be offloaded to other modules (i.e proprietary systems). An example of such a module would be a remote control system where human operators determine the next configuration.  A different implementation might use machine learning and scene detection to switch and transition to different stacks that are suitable to the current context."),(0,i.kt)("h2",{id:"runtime"},"Runtime"),(0,i.kt)("p",null,"Eclipse Muto provides an adaptive framework and a runtime  for dynamically composable model-driven ROS software stacks. Eclipse Muto can be used  to introspect, monitor and manipulate the actively running ROS graph (the network of ROS nodes). The muto runtime has two components that run on edge devices, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Agent")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Composer"),"."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"../../img/muto-components.png"})),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Agent")," is basically a ROS node that acts as gateway between the cloud (",(0,i.kt)("inlineCode",{parentName:"p"},"Muto Twin"),") and the edge device.  The composer is a high performance and lightweight  ",(0,i.kt)("inlineCode",{parentName:"p"},"Composer")," engine which can handle complex transfomations of software and lifecycle on the device. These components are build with extensibility in mind. All ",(0,i.kt)("inlineCode",{parentName:"p"},"Agent")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Composer")," capabilities are provided by muto plugins. Infact, muto comes with example plugins that you can use to customize it for your own functionality. There are two types of plugins:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Command Plugins"),"  These are plugins for the ",(0,i.kt)("inlineCode",{parentName:"li"},"Agent"),". They are called  ",(0,i.kt)("inlineCode",{parentName:"li"},"Command Plugins")," because they are used to add behavior to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Agent")," and can be invoked by a client using the mqtt protocol, and get the command response will be returned using a target topic (more on this later)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Composer Plugins")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Flows")," These are plugins for the ",(0,i.kt)("inlineCode",{parentName:"li"},"Composer"),". The ",(0,i.kt)("inlineCode",{parentName:"li"},"Composer")," behavior is driven by a ",(0,i.kt)("inlineCode",{parentName:"li"},"Flow"),", which is a lightweight orchestration definition. Each step in a flow desciption invokes a ",(0,i.kt)("inlineCode",{parentName:"li"},"Composer Plugin"),".",(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"../../img/muto-flow.png",style:{scale:"0.8"}})))),(0,i.kt)("p",null,"Muto devices are managed by their ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Digital_twin"},"digital twin"),". Muto uses ",(0,i.kt)("a",{parentName:"p",href:"https://www.eclipse.org/ditto/"},"Eclipse Ditto")," to build digital twins\nof devices connected to the cloud. We also provide a ",(0,i.kt)("a",{parentName:"p",href:"https://sandbox.composiv.ai"},(0,i.kt)("inlineCode",{parentName:"a"},"sandbox"))," and an example ",(0,i.kt)("a",{parentName:"p",href:"https://dashboard.composiv.ai"},(0,i.kt)("inlineCode",{parentName:"a"},"dashboard"))," that is connected to the sandbox to demonstrate Muto's capabilities."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"../../img/muto-topology.png",style:{scale:"0.8"}})),(0,i.kt)("h3",{id:"agent"},"Agent"),(0,i.kt)("p",null,"Agent is a runtime ROS component (Node) acting as a transceiver between the edge device and the twin server (Eclipse Ditto). Agent acts as a gateway between the device and remote management capabilities with support for asynchronous communication capabilities via MQTT. It acts as a communication bridge between edge devices  and their respective virtual twins. The main aspects of data transported by Agent are as follows:"),(0,i.kt)("h3",{id:"device-telemetry"},"Device Telemetry"),(0,i.kt)("p",null,"Agent is capable of publishing data streams up to the Twin Server, such as data that streams in ROS topics.  Stream of data mapped from edge device to virtual one, could represent instant telemetry information and/or any other device specific details. This kind of data is useful for monitoring devices and algorithmic parameters with adjustable-frequency updates. Data such as odometry, speed, localization, goal or any other drive and device related can be broadcasted via declarative models. This kind of fast paced, high frequency data moving up to digital twins is also read by Muto Dashboard to provide a graphical interface and an adequate representation of aforementioned data."),(0,i.kt)("h3",{id:"command-relay"},"Command Relay"),(0,i.kt)("p",null,"Agent relays commands from the twin server to Composer running on the edge device. This type of  information may be related to the lifecycle of ROS nodes that constitute the software stack actively running on the edge device as well as the lifecycle actions (start, stop, update etc) that may trigger the composer to respond. "),(0,i.kt)("h3",{id:"composer"},"Composer"),(0,i.kt)("p",null,"Composer is a runtime ROS component (Node) that is responsible for the life cycle of a stack; Composer uses various ROS packages and APIs to launch ROS Nodes defined by the software stacks. It can be thought of as a smart launch manager. Composer uses the stack information model and computes the delta between the current and the desired state of the ROS graph and manages the lifecycle of ROS nodes accordingly."),(0,i.kt)("h3",{id:"dashboard"},"Dashboard"),(0,i.kt)("p",null,"A simple extensible Web/Mobile application for centralized management of edge devices and software stacks. It provides a plugable micro front end architecture for extensibility and an exemplary view for managing edge devices and composable ROS stacks on these devices. It supports and uses Eclipse Ditto device twins technology (and therefore protocols such as MQTT and REST/HTTP)  for managing ROS based devices. It is designed to be modular at architectural level to make it easy to  extend for a multitude of ROS applications."),(0,i.kt)("p",{align:"center"},(0,i.kt)("img",{src:"../../img/muto-dashboard.png",style:{scale:"0.8"}})),"The dashboard provides the following functionalities:",(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Vehicles : A graphical visualization of the ROS computational network that represents the actively running ROS nodes of the current state. It displays the node-to-node and node-to-topic affiliations with introspection information ( name, subscriber, publisher etc.)"),(0,i.kt)("li",{parentName:"ul"},"Stacks: An interface to list the stack models that describe the components of a software stack that complies with the information model stored in the twin server. "),(0,i.kt)("li",{parentName:"ul"},"Remote Control Actions: An interface to manage (start,stop, update) the lifecycle of the software stack on the edge device."),(0,i.kt)("li",{parentName:"ul"},"ROS Controls: Dashboard provides a graphical UI for some of the common ROS cli commands.")),(0,i.kt)("h3",{id:"liveui"},"LiveUI"),(0,i.kt)("p",null,"Micro frontends is an architectural style where independently deliverable frontend applications are composed into a greater whole.  Muto LiveUI has been developed for building any such extensible Web or Mobile apps, such as the Muto Dashboard."),(0,i.kt)("p",null,"LiveUI opts for run-time integration via JavaScript that is tightly integrated with popular Javascript frameworks such as React.js, Vue.js and integrates well with packaging and development tools such as npm, Webpack and Metro bundler.  There is a cost to using distributed, micro service based architecture; there are more pieces, more repositories, more tools, more build/deploy pipelines, more servers, more domains, etc. We created LiveUI to help us manage some of these issues and improve the developers' experience using micro frontends. Live UI can be fully configurable to be integrated into many different devops processes and pipelines allowing many different custom project and repository layouts, test and quality tools. Development tooling and debugging experience is seamless with or without the inclusion of the container (parent) frontend."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"where-to-start"},"Where to start?"),(0,i.kt)("p",null,"You can jump to the ",(0,i.kt)("a",{parentName:"p",href:"../LiveUI/getting-started/getting-started-react"},"quick start")," section to get started with LiveUI. If you want to see some examples, check our  ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.eteration.com/eteration/labs/composiv/liveui-samples",title:"samples"},"samples repository"),"."))}m.isMDXComponent=!0}}]);